/*! @file dirac_wilson_improved_BGQ.code
  @brief Improved version of Dirac Kernel for BGQ
  This file is to substitute "dirac_wilson_improved.code"
  which contains environment-independent improvement of 
  mult_xp, mult_xm etc.
  Time-stamp: <2014-05-28 18:41:19 noaki>
*/

void Dirac_Wilson::mult_xp(Field& fp, const Field& f) const{
  int Nin = ff_.Nin();
  Field ft(fsize());
  double* ftPtr = ft.getaddr(0);
  (this->*BGWshift)(ftPtr,fPtr,Nin,BGWILSON_X,BGWILSON_FORWARD);
  
#pragma omp parallel
  {
    int ns = Nvol_/omp_get_num_threads();
    int oset = omp_get_thread_num()*ns;

    double* fPtr = const_cast<Field&>(f).getaddr(ff_.index(0,oset));    
    double* Uptr = const_cast<Field*>(u_)->getaddr(gf_.index(0,oset,XDIR));
    double Ufp[ns*Nin];

    BGWilsonSU3MultU_1D(&Ufp[0],Uptr,ftPtr,ns);

    double* fpPtr = fp.getaddr(ff_.index(0,oset));    

    for(int k=0; k<ns; ++k){    
      for(int c=0; c<NC_; ++c){
	fpPtr[r0(c)] += Ufp[r0(c)] -Ufp[i3(c)];
	fpPtr[i0(c)] += Ufp[i0(c)] +Ufp[r3(c)];
	fpPtr[r1(c)] += Ufp[r1(c)] -Ufp[i2(c)];
	fpPtr[i1(c)] += Ufp[i1(c)] +Ufp[r2(c)];
	fpPtr[r2(c)] += Ufp[i1(c)] +Ufp[r2(c)];
	fpPtr[i2(c)] -= Ufp[r1(c)] -Ufp[i2(c)];
	fpPtr[r3(c)] += Ufp[i0(c)] +Ufp[r3(c)];
	fpPtr[i3(c)] -= Ufp[r0(c)] -Ufp[i3(c)];
      }
      Ufp += Nin;
      fpPtr += Nin;
    }
  }
}

void Dirac_Wilson::mult_xm(Field& fm, const Field& f) const{
  BGWilson_Mult_Dir(Df,f,1.0,BGWILSON_X,BGWILSON_DIRAC);
  Df -= 
    
  /*
  int Nin = ff_.Nin();
  Field ft(fsize());
  
#pragma omp parallel
  {
    int ns = Nvol_/omp_get_num_threads();
    int oset = omp_get_thread_num()*ns;

    double* fPtr = const_cast<Field&>(f).getaddr(ff_.index(0,oset));    
    double* Uptr = const_cast<Field*>(u_)->getaddr(gf_.index(0,oset,XDIR));
    double Uf[ns*Nin];

    BGWilsonSU3MultUt_1D(&Uf[0],Uptr,fPtr,ns);

    double* ftPtr = ft.getaddr(ff_.index(0,oset));    

    for(int k=0; k<ns; ++k){    
      for(int c=0; c<NC_; ++c){
	ftPtr[r0(c)] += Uf[r0(c)] +Uf[i3(c)];   
	ftPtr[i0(c)] += Uf[i0(c)] -Uf[r3(c)];
	ftPtr[r1(c)] += Uf[r1(c)] +Uf[i2(c)];   
	ftPtr[i1(c)] += Uf[i1(c)] -Uf[r2(c)];
	ftPtr[r2(c)] -= Uf[i1(c)] -Uf[r2(c)];
	ftPtr[i2(c)] += Uf[r1(c)] +Uf[i2(c)];
	ftPtr[r3(c)] -= Uf[i0(c)] -Uf[r3(c)];
	ftPtr[i3(c)] += Uf[r0(c)] +Uf[i3(c)];
      }
      Uf += Nin;
      ftPtr += Nin;
    }
  }

  Field ftm(fsize());
  double* ftmPtr = ftm.getaddr(0);  
  double* ftPtr = ft.getaddr(0);  

  (this->*BGWshift)(ftmPtr,ftPtr,Nin,BGWILSON_X,BGWILSON_BACKWARD);
  fm += ftm;
  */
}



/*
void Dirac_Wilson::mult_xp(Field& fp, const Field& f) const{
  Field ft(fsize());
  double* ftPtr = ft.getaddr(0);
  double* fPtr = const_cast<Field&>(f).getaddr(0);    
  double* Uptr = const_cast<Field*>(u_)->getaddr(gf_.index(0,0,XDIR));

  (this->*BGW_mulShift)(ftPtr,Uptr,fPtr,BGWILSON_X,BGWILSON_FORWARD);

  int Nin = ff_.Nin();
#pragma omp parallel
  {
    int ns = Nvol_/omp_get_num_threads();
    int oset = omp_get_thread_num()*ns;
    double* fpPtr = fp.getaddr(ff_.index(0,oset));    
    ftPtr += ff_.index(0,oset);

    for(int k=0; k<ns; ++k){    
      for(int c=0; c<NC_; ++c){
	fpPtr[r0(c)] += ftPtr[r0(c)] - ftPtr[i3(c)];
	fpPtr[i0(c)] += ftPtr[i0(c)] + ftPtr[r3(c)];
	fpPtr[r1(c)] += ftPtr[r1(c)] - ftPtr[i2(c)];
	fpPtr[i1(c)] += ftPtr[i1(c)] + ftPtr[r2(c)];
	fpPtr[r2(c)] += ftPtr[i1(c)] + ftPtr[r2(c)];
	fpPtr[i2(c)] -= ftPtr[r1(c)] - ftPtr[i2(c)];
	fpPtr[r3(c)] += ftPtr[i0(c)] + ftPtr[r3(c)];
	fpPtr[i3(c)] -= ftPtr[r0(c)] - ftPtr[i3(c)];
      }
      ftPtr += Nin;
      fpPtr += Nin;
    }
  }
}
*/

void Dirac_Wilson::mult_yp(Field& fp, const Field& f) const{
  Field ft(fsize());
  double* ftPtr = ft.getaddr(0);
  double* fPtr = const_cast<Field&>(f).getaddr(0);    
  double* Uptr = const_cast<Field*>(u_)->getaddr(gf_.index(0,0,YDIR));

  (this->*BGW_mulShift)(ftPtr,Uptr,fPtr,BGWILSON_Y,BGWILSON_FORWARD);

  int Nin = ff_.Nin();
#pragma omp parallel
  {
    int ns = Nvol_/omp_get_num_threads();
    int oset = omp_get_thread_num()*ns;
    double* fpPtr = fp.getaddr(ff_.index(0,oset));    
    ftPtr += ff_.index(0,oset);

    for(int k=0; k<ns; ++k){    
      for(int c=0; c<NC_; ++c){
	fpPtr[r0(c)] += ftPtr[r0(c)] + ftPtr[r3(c)];
	fpPtr[i0(c)] += ftPtr[i0(c)] + ftPtr[i3(c)];
	fpPtr[r1(c)] += ftPtr[r1(c)] - ftPtr[r2(c)];
	fpPtr[i1(c)] += ftPtr[i1(c)] - ftPtr[i2(c)];
	fpPtr[r2(c)] -= ftPtr[r1(c)] - ftPtr[r2(c)];
	fpPtr[i2(c)] -= ftPtr[i1(c)] - ftPtr[i2(c)];
	fpPtr[r3(c)] += ftPtr[r0(c)] + ftPtr[r3(c)];
	fpPtr[i3(c)] += ftPtr[i0(c)] + ftPtr[i3(c)];
      }
      ftPtr += Nin;
      fpPtr += Nin;
    }
  }
}

void Dirac_Wilson::mult_zp(Field& fp, const Field& f) const{
  Field ft(fsize());
  double* ftPtr = ft.getaddr(0);
  double* fPtr = const_cast<Field&>(f).getaddr(0);    
  double* Uptr = const_cast<Field*>(u_)->getaddr(gf_.index(0,0,ZDIR));

  (this->*BGW_mulShift)(ftPtr,Uptr,fPtr,BGWILSON_Z,BGWILSON_FORWARD);

  int Nin = ff_.Nin();
#pragma omp parallel
  {
    int ns = Nvol_/omp_get_num_threads();
    int oset = omp_get_thread_num()*ns;
    double* fpPtr = fp.getaddr(ff_.index(0,oset));    
    ftPtr += ff_.index(0,oset);

    for(int k=0; k<ns; ++k){    
      for(int c=0; c<NC_; ++c){
	fpPtr[r0(c)] += ftPtr[r0(c)] - ftPtr[i2(c)];
	fpPtr[i0(c)] += ftPtr[i0(c)] + ftPtr[i2(c)];
	fpPtr[r1(c)] += ftPtr[r1(c)] + ftPtr[i3(c)];
	fpPtr[i1(c)] += ftPtr[i1(c)] - ftPtr[i3(c)];
	fpPtr[r2(c)] += ftPtr[i0(c)] + ftPtr[i2(c)];
	fpPtr[i2(c)] -= ftPtr[r0(c)] - ftPtr[i2(c)];
	fpPtr[r3(c)] -= ftPtr[i1(c)] - ftPtr[i3(c)];
	fpPtr[i3(c)] += ftPtr[r1(c)] + ftPtr[i3(c)];
      }
      ftPtr += Nin;
      fpPtr += Nin;
    }
  }
}

void Dirac_Wilson::mult_tp(Field& fp, const Field& f) const{
  Field ft(fsize());
  double* ftPtr = ft.getaddr(0);
  double* fPtr = const_cast<Field&>(f).getaddr(0);    
  double* Uptr = const_cast<Field*>(u_)->getaddr(gf_.index(0,0,TDIR));

  (this->*BGW_mulShift)(ftPtr,Uptr,fPtr,BGWILSON_T,BGWILSON_FORWARD);

  int Nin = ff_.Nin();
#pragma omp parallel
  {
    int ns = Nvol_/omp_get_num_threads();
    int oset = omp_get_thread_num()*ns;
    double* fpPtr = fp.getaddr(ff_.index(0,oset));    
    ftPtr += ff_.index(0,oset);

    for(int k=0; k<ns; ++k){    
      for(int c=0; c<NC_; ++c){
	fpPtr[r0(c)] += ftPtr[r2(c)]*2.0;
	fpPtr[i0(c)] += ftPtr[i2(c)]*2.0;
	fpPtr[r1(c)] += ftPtr[r3(c)]*2.0;
	fpPtr[i1(c)] += ftPtr[i3(c)]*2.0;
	fpPtr[r2(c)] += ftPtr[i2(c)]*2.0;
	fpPtr[i2(c)] -= ftPtr[r2(c)]*2.0;
	fpPtr[r3(c)] -= ftPtr[i3(c)]*2.0;
	fpPtr[i3(c)] += ftPtr[r3(c)]*2.0;
      }
      ftPtr += Nin;
      fpPtr += Nin;
    }
  }
}


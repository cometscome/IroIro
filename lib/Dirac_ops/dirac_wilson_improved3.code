/*
  Improved version of Dirac Kernel
  
 */

#include <xmmintrin.h>
#include <emmintrin.h>
#include <pmmintrin.h>

void Dirac_Wilson::mult_xp(Field& fp, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num of elements of a half spinor */
  int Nbdry = bdry_plw_[0].size();
  int Nbulk = bulk_pup_[0].size();
  
  double *v __attribute__ ((aligned (16)));;
  double *res;
  double *U;
  double *mat_el;

  __m128d m1, m2, m3, m4;

  /// boundary part ///
  double vbd[Nih*Nbdry] __attribute__ ((aligned (16))); /*!< @brief information on the lower boundary */   
  double vbc[Nih*Nbdry] __attribute__ ((aligned (16))); /*!< @brief information on the upper neighbor */   

  int is = 0;
  for(int k=0; k<Nbdry; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_plw_[0][k]));

    /*
    for(int c=0; c<NC_; ++c){
      __m128d pV1 = _mm_load_pd(v);
      __m128d pV2 = _mm_load_pd(v+2*NC_);
      __m128d m1 = _mm_loadr_pd(v+4*NC_);
      __m128d m2 = _mm_loadr_pd(v+6*NC_);
      
      m3 = _mm_addsub_pd(pV1, m2);
      m4 = _mm_addsub_pd(pV2, m1);
      
      _mm_store_pd(&vbd[r0(c)+is], m3);
      _mm_store_pd(&vbd[r1(c)+is], m4);
      v += 2;
     }
    */

    __m128d pV0 = _mm_load_pd(v);
    __m128d pV1 = _mm_load_pd(v+2);
    __m128d pV2 = _mm_load_pd(v+4);
    m1 = _mm_loadr_pd(v+6*NC_);
    m2 = _mm_loadr_pd(v+6*NC_+2);
    m3 = _mm_loadr_pd(v+6*NC_+4);
    
    m4 = _mm_addsub_pd(pV0, m1);
    _mm_store_pd(&vbd[is], m4);
    
    m4 = _mm_addsub_pd(pV1, m2);
    _mm_store_pd(&vbd[2+is], m4);
    
    m4 = _mm_addsub_pd(pV2, m3);
    _mm_store_pd(&vbd[4+is], m4);
    
    v+=2*NC_;
    pV0 = _mm_load_pd(v);
    pV1 = _mm_load_pd(v+2);
    pV2 = _mm_load_pd(v+4);
    m1 = _mm_loadr_pd(v+2*NC_);
    m2 = _mm_loadr_pd(v+2*NC_+2);
    m3 = _mm_loadr_pd(v+2*NC_+4);
    
    m4 = _mm_addsub_pd(pV0, m1);
    _mm_store_pd(&vbd[2*NC_+is], m4);
    
    m4 = _mm_addsub_pd(pV1, m2);
    _mm_store_pd(&vbd[2*NC_+2+is], m4);
    
    m4 = _mm_addsub_pd(pV2, m3);
    _mm_store_pd(&vbd[2*NC_+4+is], m4);
    
    is += Nih;
  }
  // Copy
  Communicator::instance()->transfer_fw(vbc,vbd,Nih*Nbdry,0);
  
  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_];     
  is = 0;
  for(int k=0; k<Nbdry; ++k){   /*!< @brief calc on the upper boundary */   
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bdry_pup_[0][k]),0));
    res = fp.getaddr(ff_.index(0,bdry_pup_[0][k]));
     for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0; v1i[c] = 0.0;
      v2r[c] = 0.0; v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	mat_el = U+re(c,c1);
	/*
	v1r[c]+= U[re(c,c1)]*vbc[r0(c1)+is] -U[im(c,c1)]*vbc[i0(c1)+is];
	v1i[c]+= U[im(c,c1)]*vbc[r0(c1)+is] +U[re(c,c1)]*vbc[i0(c1)+is];
	v2r[c]+= U[re(c,c1)]*vbc[r1(c1)+is] -U[im(c,c1)]*vbc[i1(c1)+is];
	v2i[c]+= U[im(c,c1)]*vbc[r1(c1)+is] +U[re(c,c1)]*vbc[i1(c1)+is];
	*/
	v1r[c]+= mat_el[0]*vbc[r0(c1)+is] -mat_el[1]*vbc[i0(c1)+is];
	v1i[c]+= mat_el[1]*vbc[r0(c1)+is] +mat_el[0]*vbc[i0(c1)+is];
	v2r[c]+= mat_el[0]*vbc[r1(c1)+is] -mat_el[1]*vbc[i1(c1)+is];
	v2i[c]+= mat_el[1]*vbc[r1(c1)+is] +mat_el[0]*vbc[i1(c1)+is];

      }

      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] += v2i[c];      res[i2(c)] -= v2r[c];
      res[r3(c)] += v1i[c];      res[i3(c)] -= v1r[c];

    }
    is += Nih;
  }
  /// bulk part ///
  //  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];
  double ws[NC_*4];
  for(int k=0; k<Nbulk; ++k){   /*!< @brief calc on the bulk */   
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bulk_pup_[0][k]),0));
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,(this->*x_p)(bulk_pup_[0][k],0)));
    res =fp.getaddr(ff_.index(0,bulk_pup_[0][k]));

    for(int c=0; c<NC_; ++c){
      register const int loc = 4*c;
      ws[loc  ] = v[r0(c)] -v[i3(c)];  ws[loc+2] = v[i0(c)] +v[r3(c)];
      ws[loc+1] = v[r1(c)] -v[i2(c)];  ws[loc+3] = v[i1(c)] +v[r2(c)];
    }

    __builtin_prefetch(&U[0]);
    __builtin_prefetch(&U[0]);
    register int loc;
    for(int c=0; c<NC_; ++c){
      
      v1r[c] = 0.0;  v1i[c] = 0.0;
      v2r[c] = 0.0;  v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	loc = 4*c1;
	//mat_el = U+re(c,c1);
	__builtin_prefetch(&U[re(c,c1+1)]);
	__builtin_prefetch(&U[im(c,c1+1)]);
	v1r[c] += U[re(c,c1)]*ws[loc  ] -U[im(c,c1)]*ws[loc+2];
	v1i[c] += U[im(c,c1)]*ws[loc  ] +U[re(c,c1)]*ws[loc+2];
	v2r[c] += U[re(c,c1)]*ws[loc+1] -U[im(c,c1)]*ws[loc+3];
	v2i[c] += U[im(c,c1)]*ws[loc+1] +U[re(c,c1)]*ws[loc+3];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] += v2i[c];      res[i2(c)] -= v2r[c];
      res[r3(c)] += v1i[c];      res[i3(c)] -= v1r[c];
      
    }
  }
}



void Dirac_Wilson::mult_yp(Field& fp, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num ob elements of a half spinor */
  int Nbdry = bdry_plw_[1].size();
  int Nbulk = bulk_pup_[1].size();


  double *v;
  double *res;
  double *U;

  /// boundary part ///
  double vbd[Nih*Nbdry];
  int is = 0;
  for(int k=0; k<Nbdry; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_plw_[1][k]));
    for(int c=0; c<NC_; ++c){
      vbd[r0(c)+is] = v[r0(c)]+v[r3(c)]; vbd[i0(c)+is] = v[i0(c)]+v[i3(c)];
      vbd[r1(c)+is] = v[r1(c)]-v[r2(c)]; vbd[i1(c)+is] = v[i1(c)]-v[i2(c)];
    }
    is += Nih;
  }
  double vbc[Nih*Nbdry];  //Copy vbd from backward processor
  Communicator::instance()->transfer_fw(vbc,vbd,Nih*Nbdry,1);

  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_];     
  is = 0;
  for(int k=0; k<Nbdry; ++k){
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bdry_pup_[1][k]),1));
    res = fp.getaddr(ff_.index(0,bdry_pup_[1][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0; v1i[c] = 0.0;
      v2r[c] = 0.0; v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c]+= U[re(c,c1)]*vbc[r0(c1)+is] -U[im(c,c1)]*vbc[i0(c1)+is];
	v1i[c]+= U[im(c,c1)]*vbc[r0(c1)+is] +U[re(c,c1)]*vbc[i0(c1)+is];
	v2r[c]+= U[re(c,c1)]*vbc[r1(c1)+is] -U[im(c,c1)]*vbc[i1(c1)+is];
	v2i[c]+= U[im(c,c1)]*vbc[r1(c1)+is] +U[re(c,c1)]*vbc[i1(c1)+is];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] -= v2r[c];      res[i2(c)] -= v2i[c];
      res[r3(c)] += v1r[c];      res[i3(c)] += v1i[c];
    }
    is += Nih;
  }
  /// bulk part ///
  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];

  for(int k=0; k<Nbulk; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,(this->*x_p)(bulk_pup_[1][k],1)));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] +v[r3(c)];  w1i[c] = v[i0(c)] +v[i3(c)];
      w2r[c] = v[r1(c)] -v[r2(c)];  w2i[c] = v[i1(c)] -v[i2(c)];
    }
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bulk_pup_[1][k]),1));
    res = fp.getaddr(ff_.index(0,bulk_pup_[1][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0;  v1i[c] = 0.0;
      v2r[c] = 0.0;  v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c] += U[re(c,c1)]*w1r[c1] -U[im(c,c1)]*w1i[c1];
	v1i[c] += U[im(c,c1)]*w1r[c1] +U[re(c,c1)]*w1i[c1];
	v2r[c] += U[re(c,c1)]*w2r[c1] -U[im(c,c1)]*w2i[c1];
	v2i[c] += U[im(c,c1)]*w2r[c1] +U[re(c,c1)]*w2i[c1];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] -= v2r[c];      res[i2(c)] -= v2i[c];
      res[r3(c)] += v1r[c];      res[i3(c)] += v1i[c];
    }
  }
}

void Dirac_Wilson::mult_zp(Field& fp, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num ob elements of a half spinor */
  int Nbdry = bdry_plw_[2].size();
  int Nbulk = bulk_pup_[2].size();

  double *v;
  double *res;
  double *U;

  /// boundary part ///
  double vbd[Nih*Nbdry]; 
  int is = 0;
  for(int k=0; k<Nbdry; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_plw_[2][k]));
    for(int c=0; c<NC_; ++c){
      vbd[r0(c)+is] = v[r0(c)]-v[i2(c)]; vbd[i0(c)+is] = v[i0(c)]+v[r2(c)];
      vbd[r1(c)+is] = v[r1(c)]+v[i3(c)]; vbd[i1(c)+is] = v[i1(c)]-v[r3(c)];
    }
    is += Nih;
  }
  double vbc[Nih*Nbdry];  //Copy vbd from backward processor
  Communicator::instance()->transfer_fw(vbc,vbd,Nih*Nbdry,2);

  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_];     
  is = 0;
  for(int k=0; k<Nbdry; ++k){
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bdry_pup_[2][k]),2));
    res = fp.getaddr(ff_.index(0,bdry_pup_[2][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0; v1i[c] = 0.0;
      v2r[c] = 0.0; v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c]+= U[re(c,c1)]*vbc[r0(c1)+is] -U[im(c,c1)]*vbc[i0(c1)+is];
	v1i[c]+= U[im(c,c1)]*vbc[r0(c1)+is] +U[re(c,c1)]*vbc[i0(c1)+is];
	v2r[c]+= U[re(c,c1)]*vbc[r1(c1)+is] -U[im(c,c1)]*vbc[i1(c1)+is];
	v2i[c]+= U[im(c,c1)]*vbc[r1(c1)+is] +U[re(c,c1)]*vbc[i1(c1)+is];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] += v1i[c];      res[i2(c)] -= v1r[c];
      res[r3(c)] -= v2i[c];      res[i3(c)] += v2r[c];

    }
    is += Nih;
  }
  /// bulk part ///
  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];

  for(int k=0; k<Nbulk; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,(this->*x_p)(bulk_pup_[2][k],2)));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] -v[i2(c)];  w1i[c] = v[i0(c)] +v[r2(c)];
      w2r[c] = v[r1(c)] +v[i3(c)];  w2i[c] = v[i1(c)] -v[r3(c)];
    }
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bulk_pup_[2][k]),2));
    res = fp.getaddr(ff_.index(0,bulk_pup_[2][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0;  v1i[c] = 0.0;
      v2r[c] = 0.0;  v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c] += U[re(c,c1)]*w1r[c1] -U[im(c,c1)]*w1i[c1];
	v1i[c] += U[im(c,c1)]*w1r[c1] +U[re(c,c1)]*w1i[c1];
	v2r[c] += U[re(c,c1)]*w2r[c1] -U[im(c,c1)]*w2i[c1];
	v2i[c] += U[im(c,c1)]*w2r[c1] +U[re(c,c1)]*w2i[c1];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] += v1i[c];      res[i2(c)] -= v1r[c];
      res[r3(c)] -= v2i[c];      res[i3(c)] += v2r[c];


    }
  }
}

void Dirac_Wilson::mult_tp(Field& fp, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num ob elements of a half spinor */
  int Nbdry = bdry_plw_[3].size();
  int Nbulk = bulk_pup_[3].size();


  double *v;
  double *res;
  double *U;

  /// boundary part ///
  double vbd[Nih*Nbdry]; 
  int is = 0;
  for(int k=0; k<Nbdry; ++k) {
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_plw_[3][k]));
    for(int c=0; c<NC_; ++c){
      vbd[r0(c)+is] = v[r2(c)]*2.0;  vbd[i0(c)+is] = v[i2(c)]*2.0;
      vbd[r1(c)+is] = v[r3(c)]*2.0;  vbd[i1(c)+is] = v[i3(c)]*2.0;
    }
    is += Nih;
  }  
  double vbc[Nih*Nbdry];  //Copy vbd from backward processor
  Communicator::instance()->transfer_fw(vbc,vbd,Nih*Nbdry,3);

  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_];     
  is = 0;
  for(int k=0; k<Nbdry; ++k){
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bdry_pup_[3][k]),3));
    res = fp.getaddr(ff_.index(0,bdry_pup_[3][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0; v1i[c] = 0.0;
      v2r[c] = 0.0; v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c]+= U[re(c,c1)]*vbc[r0(c1)+is] -U[im(c,c1)]*vbc[i0(c1)+is];
	v1i[c]+= U[im(c,c1)]*vbc[r0(c1)+is] +U[re(c,c1)]*vbc[i0(c1)+is];
	v2r[c]+= U[re(c,c1)]*vbc[r1(c1)+is] -U[im(c,c1)]*vbc[i1(c1)+is];
	v2i[c]+= U[im(c,c1)]*vbc[r1(c1)+is] +U[re(c,c1)]*vbc[i1(c1)+is];
      }
      res[r2(c)] += v1r[c];      res[i2(c)] += v1i[c];
      res[r3(c)] += v2r[c];      res[i3(c)] += v2i[c];
    }
    is += Nih;
  }
  /// bulk part ///
  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];

  for(int k=0; k<Nbulk; ++k) {
    double* v = const_cast<Field*>(&f)->getaddr(ff_.index(0,(this->*x_p)(bulk_pup_[3][k],3)));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r2(c)]*2.0;  w1i[c] = v[i2(c)]*2.0;
      w2r[c] = v[r3(c)]*2.0;  w2i[c] = v[i3(c)]*2.0;
    }
    double* U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gp)(bulk_pup_[3][k]),3));
    res = fp.getaddr(ff_.index(0,bulk_pup_[3][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0;  v1i[c] = 0.0;
      v2r[c] = 0.0;  v2i[c] = 0.0;
	
      for(int c1=0; c1<NC_; ++c1){
	v1r[c] += U[re(c,c1)]*w1r[c1] -U[im(c,c1)]*w1i[c1];
	v1i[c] += U[im(c,c1)]*w1r[c1] +U[re(c,c1)]*w1i[c1];
	v2r[c] += U[re(c,c1)]*w2r[c1] -U[im(c,c1)]*w2i[c1];
	v2i[c] += U[im(c,c1)]*w2r[c1] +U[re(c,c1)]*w2i[c1];
      }
      res[r2(c)] += v1r[c];      res[i2(c)] += v1i[c];
      res[r3(c)] += v2r[c];      res[i3(c)] += v2i[c];
    }
  }
}

void Dirac_Wilson::mult_xm(Field& fm, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num ob elements of a half spinor */
  int Nbdry = bdry_mup_[0].size();
  int Nbulk = bulk_mlw_[0].size();

  double *v;
  double *res;
  double *U;

  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];
  double vbc[Nih*Nbdry];  //Copy vbd from backward processor
  double vbd[Nih*Nbdry]; /*!< @brief information on the upper boundary */

  /// boundary part ///
  int is = 0;
  for(int k=0; k<Nbdry; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_mup_[0][k]));
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(bdry_mup_[0][k]),0));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] +v[i3(c)];  w1i[c] = v[i0(c)] -v[r3(c)];
      w2r[c] = v[r1(c)] +v[i2(c)];  w2i[c] = v[i1(c)] -v[r2(c)];
    }

    for(int c=0; c<NC_; ++c){
      vbd[r0(c)+is] = 0.0;  vbd[i0(c)+is] = 0.0;
      vbd[r1(c)+is] = 0.0;  vbd[i1(c)+is] = 0.0;

      for(int c1=0; c1<NC_; ++c1){
	vbd[r0(c)+is] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	vbd[i0(c)+is] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	vbd[r1(c)+is] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	vbd[i1(c)+is] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
    }
    is += Nih;
  }

  Communicator::instance()->transfer_bk(vbc,vbd,Nih*Nbdry,0);

  is = 0;
  for(int k=0; k<Nbdry; ++k){
    res = fm.getaddr(ff_.index(0,bdry_mlw_[0][k]));
    for(int c=0; c<NC_; ++c){ 
      res[r0(c)] += vbc[r0(c)+is];      res[i0(c)] += vbc[i0(c)+is];
      res[r1(c)] += vbc[r1(c)+is];      res[i1(c)] += vbc[i1(c)+is];
      res[r2(c)] -= vbc[i1(c)+is];      res[i2(c)] += vbc[r1(c)+is];
      res[r3(c)] -= vbc[i0(c)+is];      res[i3(c)] += vbc[r0(c)+is];
    }
    is += Nih;
  }
  /// bulk part ///
  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_]; 
  for(int k=0; k<Nbulk; ++k){
    int xm = (this->*x_m)(bulk_mlw_[0][k],0);
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,xm));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] +v[i3(c)];  w1i[c] = v[i0(c)] -v[r3(c)];
      w2r[c] = v[r1(c)] +v[i2(c)];  w2i[c] = v[i1(c)] -v[r2(c)];
    }
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(xm),0));
    res = fm.getaddr(ff_.index(0,bulk_mlw_[0][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0; v1i[c] = 0.0; 
      v2r[c] = 0.0; v2i[c] = 0.0;

      for(int c1=0; c1<NC_; ++c1){
	v1r[c] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	v1i[c] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	v2r[c] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	v2i[c] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] -= v2i[c];      res[i2(c)] += v2r[c];
      res[r3(c)] -= v1i[c];      res[i3(c)] += v1r[c];
    }
  }
}

void Dirac_Wilson::mult_ym(Field& fm, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num ob elements of a half spinor */
  int Nbdry = bdry_mup_[1].size();
  int Nbulk = bulk_mlw_[1].size();

  double *v;
  double *res;
  double *U;

  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];

  // boundary part  
  double vbd[Nih*Nbdry];
  int is = 0;
  for(int k=0; k<Nbdry; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_mup_[1][k]));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] -v[r3(c)];  w1i[c] = v[i0(c)] -v[i3(c)];
      w2r[c] = v[r1(c)] +v[r2(c)];  w2i[c] = v[i1(c)] +v[i2(c)];
    }
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(bdry_mup_[1][k]),1));
    for(int c=0; c<NC_; ++c){
      vbd[r0(c)+is] = 0.0;  vbd[i0(c)+is] = 0.0;
      vbd[r1(c)+is] = 0.0;  vbd[i1(c)+is] = 0.0;
	
      for(int c1=0; c1<NC_; ++c1){
	vbd[r0(c)+is] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	vbd[i0(c)+is] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	vbd[r1(c)+is] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	vbd[i1(c)+is] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
    }
    is += Nih;
  }
  double vbc[Nih*Nbdry];  //Copy v1 from backward processor
  Communicator::instance()->transfer_bk(vbc,vbd,Nih*Nbdry,1);
  is = 0;
  for(int k=0; k<Nbdry; ++k){
    res = fm.getaddr(ff_.index(0,bdry_mlw_[1][k]));
    for(int c=0; c<NC_; ++c){ 
      res[r0(c)] += vbc[r0(c)+is];      res[i0(c)] += vbc[i0(c)+is];
      res[r1(c)] += vbc[r1(c)+is];      res[i1(c)] += vbc[i1(c)+is];
      res[r2(c)] += vbc[r1(c)+is];      res[i2(c)] += vbc[i1(c)+is];
      res[r3(c)] -= vbc[r0(c)+is];      res[i3(c)] -= vbc[i0(c)+is];
    }
    is += Nih;
  }
  //bulk part
  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_];
  for(int k=0; k<Nbulk; ++k){
    int ym = (this->*x_m)(bulk_plw_[1][k],1);
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,ym));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] -v[r3(c)];  w1i[c] = v[i0(c)] -v[i3(c)];
      w2r[c] = v[r1(c)] +v[r2(c)];  w2i[c] = v[i1(c)] +v[i2(c)];
    }
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(ym),1));
    res = fm.getaddr(ff_.index(0,bulk_mlw_[1][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0; v1i[c] = 0.0; 
      v2r[c] = 0.0; v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	v1i[c] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	v2r[c] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	v2i[c] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] += v2r[c];      res[i2(c)] += v2i[c];
      res[r3(c)] -= v1r[c];      res[i3(c)] -= v1i[c];

    }
  }
}

void Dirac_Wilson::mult_zm(Field& fm, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num ob elements of a half spinor */
  int Nbdry = bdry_mup_[2].size();
  int Nbulk = bulk_mlw_[2].size();

  double *v;
  double *res;
  double *U;

  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];

  // boundary part
  double vbd[Nih*Nbdry];
  int is = 0;
  for(int k=0; k<Nbdry; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_mup_[2][k]));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] +v[i2(c)];  w1i[c] = v[i0(c)] -v[r2(c)];
      w2r[c] = v[r1(c)] -v[i3(c)];  w2i[c] = v[i1(c)] +v[r3(c)];
    }
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(bdry_mup_[2][k]),2));
    for(int c=0; c<NC_; ++c){
      vbd[r0(c)+is] = 0.0;    vbd[i0(c)+is] = 0.0;
      vbd[r1(c)+is] = 0.0;    vbd[i1(c)+is] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	vbd[r0(c)+is] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	vbd[i0(c)+is] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	vbd[r1(c)+is] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	vbd[i1(c)+is] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
    }
    is += Nih;
  }
  double vbc[Nih*Nbdry];   //Copy v1 from backward processor
  Communicator::instance()->transfer_bk(vbc,vbd,Nih*Nbdry,2);
  is = 0;
  for(int k=0; k<Nbdry; ++k){
    res = fm.getaddr(ff_.index(0,bdry_mlw_[2][k]));
    for(int c=0; c<NC_; ++c){ 
      res[r0(c)] += vbc[r0(c)+is];      res[i0(c)] += vbc[i0(c)+is];
      res[r1(c)] += vbc[r1(c)+is];      res[i1(c)] += vbc[i1(c)+is];
      res[r2(c)] -= vbc[i0(c)+is];      res[i2(c)] += vbc[r0(c)+is];
      res[r3(c)] += vbc[i1(c)+is];      res[i3(c)] -= vbc[r1(c)+is];

    }
    is += Nih;
  }
  //bulk part
  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_];
  for(int k=0; k<Nbulk; ++k){
    int zm = (this->*x_m)(bulk_mlw_[2][k],2);
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,zm));
    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)] +v[i2(c)];  w1i[c] = v[i0(c)] -v[r2(c)];
      w2r[c] = v[r1(c)] -v[i3(c)];  w2i[c] = v[i1(c)] +v[r3(c)];
    }
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(zm),2));
    res = fm.getaddr(ff_.index(0,bulk_mlw_[2][k]));
    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0; v1i[c] = 0.0; 
      v2r[c] = 0.0; v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	v1i[c] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	v2r[c] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	v2i[c] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];
      res[r2(c)] -= v1i[c];      res[i2(c)] += v1r[c];
      res[r3(c)] += v2i[c];      res[i3(c)] -= v2r[c];
      
    }
  }
}

void Dirac_Wilson::mult_tm(Field& fm, const Field& f) const{
  int Nih = Nd_*NC_; /*!< @brief num ob elements of a half spinor */
  int Nbdry = bdry_mup_[3].size();
  int Nbulk = bulk_mlw_[3].size();
  
  double *v;
  double *res;
  double *U;

  double w1r[NC_], w1i[NC_], w2r[NC_], w2i[NC_];

  /// boundary part ///
  double vbd[Nih*Nbdry];
  int is = 0;
  for(int k=0; k<Nbdry; ++k){
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,bdry_mup_[3][k]));
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(bdry_mup_[3][k]),3));

    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)]*2.0;   w1i[c] = v[i0(c)]*2.0;
      w2r[c] = v[r1(c)]*2.0;   w2i[c] = v[i1(c)]*2.0;
    }

    for(int c=0; c<NC_; ++c){
      vbd[r0(c)+is] = 0.0;  vbd[i0(c)+is] = 0.0;
      vbd[r1(c)+is] = 0.0;  vbd[i1(c)+is] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	vbd[is+r0(c)] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	vbd[is+i0(c)] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	vbd[is+r1(c)] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	vbd[is+i1(c)] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
    }
    is += Nih;
  }
  double vbc[Nih*Nbdry];  //Copy vbd from backward processor
  Communicator::instance()->transfer_bk(vbc,vbd,Nih*Nbdry,3);
  is = 0;
  for(int k=0; k<Nbdry; ++k){
    res = fm.getaddr(ff_.index(0,bdry_mlw_[3][k]));
    for(int c=0; c<NC_; ++c){  
      res[r0(c)] += vbc[r0(c)+is];      res[i0(c)] += vbc[i0(c)+is];
      res[r1(c)] += vbc[r1(c)+is];      res[i1(c)] += vbc[i1(c)+is];
    }
    is += Nih;
  }
  /// bulk part ///
  double v1r[NC_], v1i[NC_], v2r[NC_], v2i[NC_];
  for(int k=0; k<Nbulk; ++k){
    int tm = (this->*x_m)(bulk_mlw_[3][k],3);
    v = const_cast<Field*>(&f)->getaddr(ff_.index(0,tm));
    U = const_cast<Field*>(u_)->getaddr(gf_.index(0,(this->*gm)(tm),3));
    res = fm.getaddr(ff_.index(0,bulk_mlw_[3][k]));

    for(int c=0; c<NC_; ++c){
      w1r[c] = v[r0(c)]*2.0;   w1i[c] = v[i0(c)]*2.0;
      w2r[c] = v[r1(c)]*2.0;   w2i[c] = v[i1(c)]*2.0;
    }

    for(int c=0; c<NC_; ++c){
      v1r[c] = 0.0;  v1i[c] = 0.0; 
      v2r[c] = 0.0;  v2i[c] = 0.0;
      
      for(int c1=0; c1<NC_; ++c1){
	v1r[c] += U[re(c1,c)]*w1r[c1] +U[im(c1,c)]*w1i[c1];
	v1i[c] -= U[im(c1,c)]*w1r[c1] -U[re(c1,c)]*w1i[c1];
	v2r[c] += U[re(c1,c)]*w2r[c1] +U[im(c1,c)]*w2i[c1];
	v2i[c] -= U[im(c1,c)]*w2r[c1] -U[re(c1,c)]*w2i[c1];
      }
      res[r0(c)] += v1r[c];      res[i0(c)] += v1i[c];
      res[r1(c)] += v2r[c];      res[i1(c)] += v2i[c];

    }
  }
}

const Field Dirac_Wilson::gamma5(const Field& f) const{
  Field w(fsize_);
  double *ft;
  double *res;


  for(int site=0; site<Nvol_; ++site){
    int id = ff_.index(0,site);
    ft = const_cast<Field*>(&f)->getaddr(id);
    res = w.getaddr(id);

    for(int c=0; c <NC_; ++c){
      res[r0(c)] = ft[r2(c)];      res[i0(c)] = ft[i2(c)];
      res[r1(c)] = ft[r3(c)];      res[i1(c)] = ft[i3(c)];
      res[r2(c)] = ft[r0(c)];      res[i2(c)] = ft[i0(c)];
      res[r3(c)] = ft[r1(c)];      res[i3(c)] = ft[i1(c)];   

    }
  }
  return w;
}

const Field Dirac_Wilson::proj_p(const Field& f) const{
  Field w(fsize_);
  double *ft;
  double *res;

  for(int site=0; site<Nvol_; ++site){
    int id = ff_.index(0,site);
    ft = const_cast<Field*>(&f)->getaddr(id);
    res = w.getaddr(id);

    for(int c=0; c<NC_; ++c){
      double fup_r = 0.5*(ft[r0(c)] +ft[r2(c)]);
      double fup_i = 0.5*(ft[i0(c)] +ft[i2(c)]);
      double fdn_r = 0.5*(ft[r1(c)] +ft[r3(c)]);
      double fdn_i = 0.5*(ft[i1(c)] +ft[i3(c)]);

      res[r0(c)] = fup_r;      res[i0(c)] = fup_i;
      res[r1(c)] = fdn_r;      res[i1(c)] = fdn_i;
      res[r2(c)] = fup_r;      res[i2(c)] = fup_i;
      res[r3(c)] = fdn_r;      res[i3(c)] = fdn_i;   
    }
  }
  return w;
}

const Field Dirac_Wilson::proj_m(const Field& f) const{
  Field w(fsize_);
  for(int site=0; site<Nvol_; ++site){
    int id = ff_.index(0,site);
    double* ft = const_cast<Field*>(&f)->getaddr(id);

    for (int c=0; c<NC_; ++c){
      double fup_r = 0.5*(ft[r0(c)] -ft[r2(c)]);
      double fup_i = 0.5*(ft[i0(c)] -ft[i2(c)]);
      double fdn_r = 0.5*(ft[r1(c)] -ft[r3(c)]);
      double fdn_i = 0.5*(ft[i1(c)] -ft[i3(c)]);

      w.set(id+r0(c), fup_r);   w.set(id+i0(c), fup_i);
      w.set(id+r1(c), fdn_r);   w.set(id+i1(c), fdn_i);
      w.set(id+r2(c),-fup_r);   w.set(id+i2(c),-fup_i);
      w.set(id+r3(c),-fdn_r);   w.set(id+i3(c),-fdn_i);
    }
  }
  return w;
}

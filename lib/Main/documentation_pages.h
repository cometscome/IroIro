/*!

  @page configure Configuration and compilation
 
 
  @section simple Simple compilation
 
  
  For a single core run just compile with
  
  @verbatim
  ./configure
  make @endverbatim
  

  @section AIX-XLC Compilation on AIX with XLC
  
  Use the following lines
  
  @verbatim
  ./configure --enable-mpi-hitachi CXX=mpCC -host=rs6000-ibm-aix CXXFLAGS="-I/srhome/scqcd/cossu/gsl/include -qlanglvl=stdc99 -qrtti=type" LDFLAGS="-L/srhome/scqcd/cossu/gsl/lib"
  gmake@endverbatim
  
  In order to override the default optimization level just add the 
  
  @verbatim
  "-qoptimize=#"@endverbatim 
  
  option inside the \c CXXFLAGS (where # in between 1 - 5)
 

  @section openMPI Compilation on MPI capable general machine
 
  Use this on a general multicore machine with openMPI installed

  @verbatim
  ./configure --enable-mpi CXX=mpicxx.openmpi
  @endverbatim

  Run with <tt>mpirun -np #nodes #executable</tt>
  
  @section testing Testing and debugging

  @verbatim
  valgrind --leak-check=yes --log-file=valgrind.log #executable@endverbatim
  
  
  @section verbosity Verbosity control 
  
  In order to set the verbosity of executable files during runtime use the variable \c code_verbosity in configuration.
  
  Example
  @verbatim
  ./configure code_verbosity=5@endverbatim
  
  sets maximum verbosity. Allowed values from 0 to 5. Default is 1.
  

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
  @page Using XML input

  The code uses %XML files for controlling parameters and object creation.

  Refer to the following section for detailed description:

  - \subpage creation_basic
  - \subpage creation_HMC
  - \subpage actionPage

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!

  @page creation_basic Creating %XML for %HMC runs (Basics)
  
  The %XML file starts with the declaration of type
  
  @verbatim <?xml version="1.0" encoding="UTF-8" ?>@endverbatim

  Remember that every section (element) must be opened and closed in the following way
  @verbatim
  <SectionName>
  ..... useful stuff, eventually nested sections
  </SectionName>@endverbatim

  %XML parser is case sensitive.

  The very first entry should always be a \c \<Parameters\> 
  element that is  closed at the end of the file by \c \</Parameters\> .

  This element encloses all the parameters needed to execute the program.

  The following, mandatory section is \c \<%Geometry\> that contains the \c \<%Lattice\> and \c \<%Nodes\> elements.

  \c \<%Lattice\> element contains 4 integers separated by spaces that define the global lattice in 4 dimensions.

  \c \<%Node\> element will contain 4 integers separated by spaces that describe the machine geometry in the four directions. 

  Following \c \<%Geometry\> is the \c \<%Configuration\> section.

  \c \<%Configuration\> contains a type tag and will eventually declare the initial configuration file.
 
  A typical line is the following 

  @verbatim
  <Configuration Type="Binary">my_conf.bin</Configuration>@endverbatim

  Possible types are  
  - \b Unit (start from all unit links, filename is ignored if present)
  - \b TextFile (text file containing the configuration in one single column)
  - \b Binary (binary file - binary format is the same as ILDG but no XML header by now)
  - \b JLQCDLegacy (reads the configurations generated by IBM BlueGene/L at KEK)

  After these initial descriptions the \c \<%HMC\> section starts. See page \ref creation_HMC

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!

  @page creation_HMC Creating %XML for %HMC runs (%HMC section)

  The %HMC section describes the core of the calculation.

  A typical appearance is the following one
  @verbatim
   <HMC>
    <Nsweeps>1000</Nsweeps>
    <Thermalization>100</Thermalization>
    <RandomNumberGen name="Mersenne Twister">
      <seedFile>seed_file</seedFile>
    </RandomNumberGen>
    
    <Integrator name="leapfrog_multistep">
    .... lot of info described later
    </Integrator>
   </HMC>@endverbatim

   The sections \c \<%Nsweeps\> and \c \<%Thermalizations\> do exactly what one expects: declare the number of sweeps for be performed and the number of thermalization steps to be done before that.

   The \c \<%RandomNumberGen\> section describes and initializes the random number generator.
   Only one choice is available at the moment: <b>Mersenne Twister</b> generator.

   Random number generator can be provided with a seed file in the same way as the example or can be initialized by the \c \<%init\> section with a sequence of integers (in decimal or hexadecimal format).

   The presence of the  \c \<%seedFile\> section supersedes the \c \<%init\> section, that is ignored if present.

   @section integrator \<Integrator\>  section

   This section declare the whole structure for the Molecular Dynamics trajectory.

   Mandatory items are shown in the example below

   @verbatim
    <Integrator name="leapfrog_multistep">
      <MDsteps>3</MDsteps>
      <step_size>0.00004</step_size>
      <exp_approx>8</exp_approx>
      <step>
	<multiplier>1</multiplier>
	<Action ...>
	...
	</Action>
        <step>
	  <multiplier>1</multiplier>
	  <Action ...>
          ...
          </Action>
	</step>
      </step>
    </Integrator>@endverbatim

    The integrator name is declared by the \c name tag. Currently available names are

    - \b leapfrog_multistep (leapfrog integrator with multiple time scales)

    The three mandatory sections are \c \<%MDsteps\> , \c \<%step_size\> , \c \<%exp_approx\> that respectively declare the number of steps in the Molecular Dynamics evolution, the step size and the degree of approximation in the exponential function.

    The definition if the Hamiltonian is given by the several action terms that can be combined together. 

    @subsection leapfrog_multi The leapfrog_multistep integrator

    In the case of multistep integrator every action belongs to a step level. Step levels are declared in a nested tree. Every nested level automatically declares a new time scale. The step size of the new time scale is controlled by the \c \<%multiplier\> section (accepting integer values): a multiplier value of 2 for example divide by 2 the step size, resulting in a finer integration of that level <em>with respect to the previous one</em>.

    Multiple actions can belong to the same level. 

    The actions are discussed in the \ref actionPage 

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!

    @page actionPage Creating %XML for %HMC runs (%Action section)

    The \c \<%Action\> section declares a piece of the Hamiltonian, fermionic or gauge piece. It contains two tags, the \c type and \c name . 

    The \c type tag can have two different values with obvious meaning
    - \b Gauge 
    - \b Fermion

    Possible names for the action are (in the current implementation) 
    - \b Gauge
         - \b Wilson (Wilson type action, class ActionGaugeWilson)
	 - \b Rectangle (Rectangle type action, class ActionGaugeRect)
	 - \b Iwasaki (Iwasaki type action, specialization of ActionGaugeRect)
	 - \b Symanzik (Symanzik type action, specialization of ActionGaugeRect)
	 - \b DBW2 (DBW2 type action, specialization of ActionGaugeRect)
    - \b Fermion
         - \b TwoFlavors (Two flavors action, class Action_Nf2)
	 - \b TwoFlavorsRatio (Two flavors ratio of operators, class Action_Nf2_ratio)
	 - \b TwoFlavorsDomainWall (%Action for two flavors of Domain Wall fermions, class Action_Nf2_DomainWall)
	 - \b TwoFlavorsEvenOdd (%Action for two flavors even-odd preconditioned, class Action_Nf2_EvenOdd)

    Each one of these will be explained in the following sections.

    @section GWilson Gauge - Wilson action

    The action is \f$ S_G = \frac{\beta}{N_c} \sum P^{1 \times 1}\f$
    
    This is easily defined by a structure like:

    @verbatim
    <Action type="Gauge" name="Wilson">
      <beta>6.0</beta>
    </Action>@endverbatim
    
    Just the \c \<%beta\> section is necessary an provides the \f$ \beta \f$ value.


    @section GRect Gauge - Rectangle action

    The action is \f$ S_G = \frac{\beta}{N_c}( \sum c_1 \cdot P^{1 \times 1} + \sum  c_2 \cdot P^{1 \times 2})\f$

    Defined in a way similar to the standard Wilson action plus the two additional parameters \c c_plaq and \c c_rect

    @verbatim
    <Action type="Gauge" name="Rectangle">
      <beta>2.0</beta>
      <c_plaq>2.0</c_plaq>
      <c_rect>1.5</c_rect>
    </Action>@endverbatim
 
    @section GRectSpecial Gauge - Iwasaki, Symanzik, DBW2 actions

    These are defined in a way identical to the Wilson action since the coefficients for the several terms are automatically defined in the code, being respectively:

    - Iwasaki action: \f$c_1 =  3.648\f$, \f$c_2 = -0.331\f$
    - Symanzik action: \f$c_1 =  5/3\f$, \f$c_2 = -1/12\f$
    - DBW2 action: \f$c_2 =  12.2704\f$, \f$c_2 = -1.4088\f$
    
    So, a construction will look like the following:
 
    @verbatim
    <Action type="Gauge" name="Iwasaki">
      <beta>2.25</beta>
    </Action>@endverbatim


    @section FActionNf2 Fermion - TwoFlavors

    In principle this action accepts all kind of fermions, but in the current implementation only Wilson fermions are fine. This is a quite simple action too, no parameters except the declaration of the kernel are necessary.

    The example code is 
    @verbatim
    <Action type="Fermion" name="TwoFlavors">
      <Kernel name="DiracWilson">
        <mass>1.0</mass>
      </Kernel>
      <Solver type="Solver_CG">
        <MaxIter>1000</MaxIter>
	<Precision>10e-8</Precision>
      </Solver>
    </Action>@endverbatim

    The \c \<%Kernel\> section is mandatory and accepts a \c name tag for the %Dirac operator object. Please refer to \ref DiracOps for the DiracWilson operator.

    The \c \<%Solver\> section is mandatory as well, and declares which kind of linear solver should be used to calculate \f$ D_w^{-1}\f$. Refer to the page \ref solversPage for further details on different solvers.

    @section FActionNf2ratio Fermion - TwoFlavorsRatio

    The \c TwoFlavorsRatio action is constructed in the following way

    @verbatim
    <Action type="Fermion" name="TwoFlavorsRatio">
      <Numerator name="your Dirac operator">
      ... dirac parameters
      </Numerator>
      
      <Denominator name="another Dirac operator">
      ... dirac parameters
      </Denominator>
      
      <SolverNumerator type="your solver name for numerator">
      ... solver parameters
      </SolverNumerator>
      
      <SolverDenominator type="your solver name for denominator">
      ... solver parameters
      </SolverDenominator>
    </Action>@endverbatim
    
    The meaning of the several sections is self-explanatory. Refer to \ref DiracOps and  \ref solversPage for details on Dirac Operators and linear Solvers.
	

    @section FActionDWF Fermion - TwoFlavorsDomainWall

    A simple example is better to explain how to construct this action

    @verbatim
    <Action type="Fermion" name="TwoFlavorsDomainWall">
      <Kernel5D>
       ...
      </Kernel5D>
      <Solver type="your favourite solver name">
       ...
      </Solver>  
    </Action>@endverbatim

    The structure is very simple. The \c \<%Kernel5D\> will automatically construct a 5D Domain Wall operator with parameters described in section \ref DDWF5d .

    For possible solver names and parameters to be provided please refer to the page for \ref solversPage . 

    @section FActionEO Fermion - TwoFlavorsEvenOdd

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////
/*!    


    @page DiracOps %Dirac operators

    Several %Dirac operators are defined in the current version of the code and can be referenced with the following names (case sensitive)

    - \b DiracWilson (Wilson fermions Dirac operator, class Dirac_Wilson)
    - \b DiracWilson_EvenOdd (Wilson fermions Dirac operator with even-odd preconditioning, class Dirac_Wilson_EvenOdd)
    - \b DiracOptimalDomainWall4d (4 dimensional Domain Wall operator, class Dirac_optimalDomainWall_4D - uses the 5 dimensional operator as a member)
    - \b DiracOptimalDomainWall5d (5 dimensional representation of Domain Wall operator, class Dirac_optimalDomainWall)

    @section DWilson DiracWilson operator

    This operator needs the structure:

    @verbatim
    <... name="DiracWilson">
       <mass>1.0</mass>
    </...>@endverbatim

    Dots are used because the section name requesting the operator depends on the upper level in xml file (see for examples the \ref actionPage ). 

    Only the \c \<%mass\> section is necessary. The mass is related to \f$\kappa\f$ by the relation
    \f[ \kappa = \frac{1}{2(4+m)}\f]

    @section DWilsonEO DiracWilson_EvenOdd operator

    @section DDWF4d DiracOptimalDomainWall4d operator

    @section DDWF5d DiracOptimalDomainWall5d operator

    The 5 dimensional Domain Wall operator is described by several parameters like in the following code snippet:
 
    @verbatim
    <... name="DiracOptimalDomainWall5d>
      <Preconditioning>NoPreconditioner</Preconditioning>
      <Kernel name="DiracWilson">
        <mass>-1.8</mass>
      </Kernel>
      <N5d>6</N5d>
      <b>2.0</b>
      <c>0.0</c>
      <mass>0.10</mass>
      <approximation name="Zolotarev">
        <lambda_min>0.1</lambda_min>
	<lambda_max>1.5</lambda_max>
      </approximation>
     </...>@endverbatim

     The \c \<%Preconditioning\> section declares which kind of preconditioners are allowed for this operator
     Choices are
     - \b NoPreconditioner (no preconditioner is applied before matrix inversion)
     - \b LUPreconditioner (LU preconditioner is applied - \b must be used in conjunction with a preconditioned linear solver, otherwise wrong results will be obtained).

     The \c \<%Kernel\> section refers to the Dirac kernel to be used inside the Domain Wall operator, in this case a Wilson operator with mass = -1.8 .
     
     Sections \c \<%N5d\> \c \<%b\> \c \<%c\> and \c \<%mass\> provide respectively the length of the fifth dimension, the \f$b\f$ and \f$c\f$ parameters and the mass \f$m\f$ like in the following equation

     \f[ insert-equation \f]

     The \c \<%approximation\> section is used to generate the weights of the 5 dimensional layers. We have two choices, the hyperbolic tangent case (giving the usual domain wall formulation) and the Zolotarev case (giving a better approximation of the sign function). Therefore the \c name tag has two variations:
     - \b Tanh (no further parameters are needed)
     - \b Zolotarev (needs the interval of approximation like in the example)



*/
///////////////////////////////////////////////////////////////////////////////////////////////////////
/*!
  
  @page solversPage Linear solvers
  
  Solving linear equations requires the definition of a Solver object. Typically they are needed inside actions or quark propagators. Name is always specified by the tag \c name.
  
  Possible entries for the names are:
  - \b %Solver_CG (Conjugate gradient linear solver)
  - \b %Solver_CG_Precondition (Conjugate gradient linear solver with preconditioning, must be used together with a preconditioned Dirac operator otherwise no preconditioning is applied)
  - \b %Solver_BiCGStab (Bi-Conjugate gradient stabilized linear solver)
  
  @section SolvCG Solver_CG
  
  It uses the Conjugate gradient linear solver to invert matrices and requires the \c \<%MaxIter\> and \c \<%Precision\> sections like in the following example:

  @verbatim
  <... type="Solver_CG">
    <MaxIter>1000</MaxIter>
    <Precision>1e-8</Precision>
  </...>@endverbatim

  Name of solver section is dependent on caller (upper level of xml file).

  \MaxIter and \Precision respectively provide the maximum number of iterations for the solver (program aborts if iterations go beyond this limit) and the precision goal for the residual, the stopping condition.
  
 
  @section SolvCGPrec Solver_CG_Precondition

  This is totally analogous to the Solver_CG declaration.

  @section SolvBiCGStab Solver_BiCGStab

  Refer to the Solver_CG for details, parameters to be declared are the same.



 */

